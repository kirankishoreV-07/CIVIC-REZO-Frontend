import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Alert,
  TouchableOpacity,
  ActivityIndicator,
  StatusBar,
  Modal,
  Platform,
  TextInput,
  Keyboard,
  ScrollView,
  Image,
} from 'react-native';
import MapView, { Marker, Callout, Circle } from 'react-native-maps';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as Location from 'expo-location';
import EnvironmentalTheme from '../../theme/EnvironmentalTheme';
import { API_BASE_URL, apiClient, makeApiCall } from '../../../config/supabase';

// Using API_BASE_URL from config instead of hardcoded URL
// This ensures consistent API access across different environments

// Note: EnvironmentalTheme is now imported directly at the top of the file

const ComplaintMapScreen = ({ navigation, route }) => {
  // Safe theme access functions
  const getThemeColor = (path, defaultColor) => {
    try {
      // Parse dot notation path like 'primary.main'
      const parts = path.split('.');
      let value = EnvironmentalTheme;
      for (const part of parts) {
        if (!value || typeof value !== 'object') return defaultColor;
        value = value[part];
      }
      return value || defaultColor;
    } catch (e) {
      return defaultColor;
    }
  };
  
  const getGradient = (name, defaultGradient) => {
    try {
      return EnvironmentalTheme?.gradients?.[name] || defaultGradient;
    } catch (e) {
      return defaultGradient;
    }
  };
  
  const getThemeValue = (path, defaultValue) => {
    try {
      // Parse dot notation path like 'shadows.medium'
      const parts = path.split('.');
      let value = EnvironmentalTheme;
      for (const part of parts) {
        if (!value || typeof value !== 'object') return defaultValue;
        value = value[part];
      }
      return value || defaultValue;
    } catch (e) {
      return defaultValue;
    }
  };

  // Safely access route props with fallbacks
  const routeParams = route?.params || {};
  
  const [complaints, setComplaints] = useState([]);
  const [heatMapData, setHeatMapData] = useState([]); // Initialize as empty array
  const [loading, setLoading] = useState(true);
  const [selectedComplaint, setSelectedComplaint] = useState(null);
  const [showComplaintModal, setShowComplaintModal] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  const [filterStatus, setFilterStatus] = useState('all');
  const [statistics, setStatistics] = useState(null);
  const [showSearchModal, setShowSearchModal] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [searchMarker, setSearchMarker] = useState(null);
  const [recentSearches, setRecentSearches] = useState([]);
  const searchQueryRef = React.useRef('');
  const [location, setLocation] = useState(null);
  const [errorMsg, setErrorMsg] = useState(null);
  const [region, setRegion] = useState({
    latitude: 19.758, // Center between Delhi and Palakkad areas
    longitude: 77.053, 
    latitudeDelta: 20.0, // Wide enough to show both complaint areas
    longitudeDelta: 1.0,
  });
  const [mapRef, setMapRef] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [autoRefresh, setAutoRefresh] = useState(false);
  const [lastUpdated, setLastUpdated] = useState(new Date());
  const [isFetching, setIsFetching] = useState(false);
  const [showHeatmap, setShowHeatmap] = useState(true);
  // Use ref to track fetching state across renders
  const isFetchingRef = React.useRef(false);

  // Fetch user location on component mount
  useEffect(() => {
    (async () => {
      console.log('üåç Getting user location...');
      try {
        let { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          console.log('‚ùå Location permission denied');
          setErrorMsg('Permission to access location was denied. Showing complaint areas.');
          // Still fetch complaints even without location permission
          fetchComplaintData();
          return;
        }

        console.log('‚úÖ Location permission granted, getting current position...');
        // Get current position with high accuracy
        let locationResult = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.High,
          timeout: 10000,
          maximumAge: 60000, // Cache for 1 minute
        });
        
        console.log('üìç User location obtained:', locationResult.coords);
        setLocation(locationResult);
        
        // Set map region to user's location with appropriate zoom
        if (locationResult?.coords) {
          const userRegion = {
            latitude: locationResult.coords.latitude,
            longitude: locationResult.coords.longitude,
            latitudeDelta: 0.05, // Good zoom level to see nearby complaints
            longitudeDelta: 0.05,
          };
          
          console.log('üó∫Ô∏è Setting map region to user location:', userRegion);
          setRegion(userRegion);
          
          // Animate to user location if map is ready
          if (mapRef) {
            setTimeout(() => {
              mapRef.animateToRegion(userRegion, 1000);
            }, 500);
          }
        }
      } catch (error) {
        console.error('‚ùå Error getting location:', error);
        setErrorMsg('Could not get your location. Showing complaint areas.');
        
        // Set region to show complaint areas
        setRegion({
          latitude: 19.758,
          longitude: 77.053,
          latitudeDelta: 20.0,
          longitudeDelta: 1.0,
        });
      } finally {
        // Always fetch complaint data
        fetchComplaintData();
      }
    })();
    
    // Set up auto-refresh if enabled
    let refreshInterval;
    if (autoRefresh) {
      refreshInterval = setInterval(() => {
        if (!isFetchingRef.current) {
          fetchComplaintData();
        }
      }, 30000); // Refresh every 30 seconds
    }
    
    return () => {
      if (refreshInterval) clearInterval(refreshInterval);
    };
  }, [autoRefresh]);

  // Function to fetch complaint data from the API
  const fetchComplaintData = async () => {
    if (isFetchingRef.current) return; // Prevent duplicate fetches
    
    isFetchingRef.current = true;
    setIsFetching(true);
    
    try {
      console.log('Fetching complaint data...');
      
      // Fetch complaints
      const response = await fetch(`${API_BASE_URL}/api/complaints`);
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      
      const responseData = await response.json();
      console.log('API Response:', responseData);
      
      // Extract complaints array from response
      const complaintsArray = responseData.success ? responseData.complaints : [];
      console.log(`Fetched ${complaintsArray.length} complaints`);
      
      setComplaints(complaintsArray);
      console.log(`üìù Set complaints state with ${complaintsArray.length} items:`, complaintsArray.map(c => ({ id: c.id, title: c.title, status: c.status })));
      
      // Calculate statistics
      const stats = {
        pending: complaintsArray.filter(c => c.status === 'pending').length,
        active: complaintsArray.filter(c => c.status === 'in_progress').length,
        resolved: complaintsArray.filter(c => c.status === 'completed').length,
        total: complaintsArray.length
      };
      
      setStatistics(stats);
      
      // Auto-fit map to show all complaints after loading
      console.log(`üìç Auto-fitting map to show all ${complaintsArray.length} complaints...`);
      fitMapToComplaints(complaintsArray);
      
      // Fetch heatmap data
      await fetchHeatMapData();
      
      // Also generate heatmap from complaints as fallback
      if (!heatMapData || heatMapData.length === 0) {
        generateHeatmapFromComplaints();
      }
      
      // Auto-fit map region to show all complaints
      fitMapToComplaints(complaintsArray);
      
      setLastUpdated(new Date());
    } catch (error) {
      console.error('Error fetching complaint data:', error);
      Alert.alert(
        'Data Loading Error',
        'Could not load complaint data. Please check your internet connection and try again.',
        [{ text: 'OK' }]
      );
    } finally {
      setLoading(false);
      setIsFetching(false);
      isFetchingRef.current = false;
    }
  };

  // Function to fetch heatmap data
  const fetchHeatMapData = async () => {
    try {
      console.log('Fetching heatmap data...');
      
      const response = await fetch(`${API_BASE_URL}/api/heat-map/data`);
      if (!response.ok) {
        throw new Error(`Heatmap API error: ${response.status}`);
      }
      
      const responseData = await response.json();
      console.log('Heatmap API Response:', responseData);
      
      // Extract the actual data from the response
      const heatmapPoints = responseData.success ? responseData.data?.points || [] : [];
      console.log(`Fetched ${heatmapPoints.length} heatmap points`);
      
      // Generate heatmap from complaint data if no specific heatmap data
      if (!heatmapPoints || heatmapPoints.length === 0) {
        console.log('No heatmap data, generating from complaints');
        generateHeatmapFromComplaints();
        return;
      }
      
      setHeatMapData(heatmapPoints);
    } catch (error) {
      console.error('Error fetching heatmap data:', error);
      // Generate heatmap from complaints on error
      generateHeatmapFromComplaints();
    }
  };

  // Auto-fit map region to show all complaints
  const fitMapToComplaints = (complaintsData) => {
    if (!complaintsData || complaintsData.length === 0) {
      console.log('‚ö†Ô∏è No complaints data to fit map to');
      return;
    }
    
    const validComplaints = complaintsData.filter(complaint => {
      const lat = parseFloat(complaint.location_latitude);
      const lng = parseFloat(complaint.location_longitude);
      const isValid = !isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0;
      
      if (!isValid) {
        console.log(`‚ö†Ô∏è Invalid coordinates for complaint ${complaint.id}: ${lat}, ${lng}`);
      }
      
      return isValid;
    });
    
    if (validComplaints.length === 0) {
      console.log('‚ö†Ô∏è No complaints with valid coordinates found');
      return;
    }
    
    console.log(`üìç Fitting map to ${validComplaints.length} valid complaints:`);
    validComplaints.forEach(c => {
      console.log(`  - ${c.title}: ${c.location_latitude}, ${c.location_longitude}`);
    });
    
    const lats = validComplaints.map(c => parseFloat(c.location_latitude));
    const lngs = validComplaints.map(c => parseFloat(c.location_longitude));
    
    const minLat = Math.min(...lats);
    const maxLat = Math.max(...lats);
    const minLng = Math.min(...lngs);
    const maxLng = Math.max(...lngs);
    
    const centerLat = (minLat + maxLat) / 2;
    const centerLng = (minLng + maxLng) / 2;
    
    // Calculate deltas with appropriate padding
    let latDelta = (maxLat - minLat);
    let lngDelta = (maxLng - minLng);
    
    // If all complaints are very close together, set minimum zoom
    if (latDelta < 0.01) latDelta = 0.02; // ~2km zoom
    if (lngDelta < 0.01) lngDelta = 0.02;
    
    // Add padding (50% more than the span)
    latDelta *= 1.5;
    lngDelta *= 1.5;
    
    // Ensure reasonable zoom limits
    latDelta = Math.max(0.01, Math.min(latDelta, 20)); // Max 20 degrees
    lngDelta = Math.max(0.01, Math.min(lngDelta, 20));
    
    const newRegion = {
      latitude: centerLat,
      longitude: centerLng,
      latitudeDelta: latDelta,
      longitudeDelta: lngDelta,
    };
    
    console.log('ÔøΩÔ∏è Setting map region:', {
      center: `${centerLat.toFixed(4)}, ${centerLng.toFixed(4)}`,
      deltas: `${latDelta.toFixed(4)}, ${lngDelta.toFixed(4)}`,
      bounds: `${minLat.toFixed(4)}-${maxLat.toFixed(4)}, ${minLng.toFixed(4)}-${maxLng.toFixed(4)}`
    });
    
    setRegion(newRegion);
    
    // Also animate the map if mapRef is available
    if (mapRef) {
      setTimeout(() => {
        console.log('üé¨ Animating map to new region...');
        mapRef.animateToRegion(newRegion, 1500);
      }, 800);
    }
  };

  // Generate heatmap data from actual complaints
  const generateHeatmapFromComplaints = () => {
    console.log('Generating heatmap data from complaints');
    
    if (!complaints || complaints.length === 0) {
      console.log('No complaints available for heatmap');
      setHeatMapData([]);
      return;
    }
    
    const heatmapData = complaints
      .filter(complaint => {
        const lat = parseFloat(complaint.location_latitude);
        const lng = parseFloat(complaint.location_longitude);
        return !isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0;
      })
      .map(complaint => {
        const lat = parseFloat(complaint.location_latitude);
        const lng = parseFloat(complaint.location_longitude);
        
        // Calculate weight based on priority score and status
        let weight = Math.ceil((complaint.priority_score || 0.5) * 10); // Convert 0-1 to 1-10
        
        // Increase weight for pending/active complaints
        if (complaint.status === 'pending') weight *= 1.5;
        else if (complaint.status === 'in_progress') weight *= 1.2;
        else if (complaint.status === 'completed') weight *= 0.5;
        
        // Ensure weight is between 1-10
        weight = Math.max(1, Math.min(10, Math.round(weight)));
        
        return {
          latitude: lat,
          longitude: lng,
          weight: weight,
          id: complaint.id,
          title: complaint.title,
          status: complaint.status
        };
      });
    
    console.log(`Generated ${heatmapData.length} heatmap points from complaints`);
    setHeatMapData(heatmapData);
  };

  // Generate test heatmap data around the current map center (fallback)
  const generateTestHeatmap = () => {
    console.log('Generating test heatmap data');
    
    const testData = [];
    // Generate 10 random points around the current region
    for (let i = 0; i < 10; i++) {
      const latOffset = (Math.random() - 0.5) * 0.05;
      const lonOffset = (Math.random() - 0.5) * 0.05;
      const weight = Math.floor(Math.random() * 10) + 1; // Random weight between 1-10
      
      testData.push({
        latitude: region.latitude + latOffset,
        longitude: region.longitude + lonOffset,
        weight: weight
      });
    }
    
    console.log(`Generated ${testData.length} test heatmap points`);
    setHeatMapData(testData);
  };

  // Function to go to user's current location on the map
  const goToUserLocation = async () => {
    try {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          'Location Permission',
          'Please enable location services to use this feature.',
          [{ text: 'OK' }]
        );
        return;
      }
      
      const currentLocation = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.Balanced,
      });
      
      if (currentLocation?.coords && mapRef) {
        const newRegion = {
          latitude: currentLocation.coords.latitude,
          longitude: currentLocation.coords.longitude,
          latitudeDelta: 0.01, // Zoom in more than initial
          longitudeDelta: 0.01,
        };
        
        mapRef.animateToRegion(newRegion, 1000);
      }
    } catch (error) {
      console.error('Error getting current location:', error);
      Alert.alert(
        'Location Error',
        'Could not get your current location. Please try again.',
        [{ text: 'OK' }]
      );
    }
  };

  // Function to search for a location
  const searchLocation = async () => {
    if (!searchQuery.trim()) return;
    
    setIsSearching(true);
    
    try {
      // This would typically call a geocoding API
      // For demo purposes, we'll create a marker at a slight offset from current position
      const latOffset = (Math.random() - 0.5) * 0.02;
      const lonOffset = (Math.random() - 0.5) * 0.02;
      
      const result = {
        latitude: region.latitude + latOffset,
        longitude: region.longitude + lonOffset,
        title: searchQuery,
        description: `Found location for "${searchQuery}"`
      };
      
      // Add to recent searches
      const newSearch = { query: searchQuery, timestamp: new Date().getTime() };
      setRecentSearches(prev => {
        // Filter out duplicates and keep only the 5 most recent
        const filteredSearches = prev.filter(s => s.query.toLowerCase() !== searchQuery.toLowerCase());
        return [newSearch, ...filteredSearches].slice(0, 5);
      });
      
      // Set the search marker and animate map to it
      setSearchMarker(result);
      if (mapRef) {
        mapRef.animateToRegion({
          latitude: result.latitude,
          longitude: result.longitude,
          latitudeDelta: 0.01,
          longitudeDelta: 0.01,
        }, 1000);
      }
      
      // Close search modal
      setShowSearchModal(false);
    } catch (error) {
      console.error('Error searching location:', error);
      Alert.alert(
        'Search Error',
        'Could not find the location. Please try a different search term.',
        [{ text: 'OK' }]
      );
    } finally {
      setIsSearching(false);
    }
  };

  // Test API endpoints for debugging
  const testApiEndpoints = async () => {
    try {
      Alert.alert(
        'Testing API',
        'Attempting to connect to backend API endpoints...',
        [{ text: 'OK' }]
      );
      
      // Test complaints endpoint
      const complaintsResponse = await fetch(`${API_BASE_URL}/api/complaints`);
      const complaintsStatus = complaintsResponse.ok ? 'SUCCESS' : 'FAILED';
      
      // Test heatmap endpoint
      const heatmapResponse = await fetch(`${API_BASE_URL}/api/heat-map/data`);
      const heatmapStatus = heatmapResponse.ok ? 'SUCCESS' : 'FAILED';
      
      Alert.alert(
        'API Test Results',
        `Complaints API: ${complaintsStatus}\nHeatmap API: ${heatmapStatus}\n\nIf any failed, check your backend server connection.`,
        [{ text: 'OK' }]
      );
      
      // Generate test data regardless of result
      generateTestHeatmap();
    } catch (error) {
      console.error('API test error:', error);
      Alert.alert(
        'API Test Failed',
        'Could not connect to API endpoints. Generating test data instead.',
        [{ text: 'OK' }]
      );
      
      // Generate test data on error
      generateTestHeatmap();
    }
  };

  // Filter complaints based on status
  const getFilteredComplaints = () => {
    if (!complaints || !Array.isArray(complaints)) {
      console.log(`‚ö†Ô∏è getFilteredComplaints: complaints is not an array:`, complaints);
      return [];
    }
    
    console.log(`üîç getFilteredComplaints: filtering ${complaints.length} complaints with status '${filterStatus}'`);
    
    if (filterStatus === 'all') {
      console.log(`üìã getFilteredComplaints: returning all ${complaints.length} complaints`);
      return complaints;
    }
    
    const filtered = complaints.filter(complaint => complaint.status === filterStatus);
    console.log(`üìã getFilteredComplaints: filtered to ${filtered.length} complaints with status '${filterStatus}'`);
    return filtered;
  };

  // Get color based on complaint status
  const getStatusColor = (status) => {
    switch (status?.toLowerCase()) {
      case 'completed':
      case 'resolved':
        return '#00AA44'; // Green - Solved
      case 'in_progress':
      case 'under_review':
        return '#FFD700'; // Yellow - In Progress
      case 'pending':
      case 'new':
      default:
        return '#FF4444'; // Red - Registered/Pending
    }
  };

  // Get status display text
  const getStatusText = (status) => {
    switch (status?.toLowerCase()) {
      case 'completed':
      case 'resolved':
        return 'Solved';
      case 'in_progress':
      case 'under_review':
        return 'In Progress';
      case 'pending':
      case 'new':
      default:
        return 'Registered';
    }
  };

  // Get status icon
  const getStatusIcon = (status) => {
    switch (status?.toLowerCase()) {
      case 'completed':
      case 'resolved':
        return 'checkmark-circle';
      case 'in_progress':
      case 'under_review':
        return 'time';
      case 'pending':
      case 'new':
      default:
        return 'alert-circle';
    }
  };

  // Get days ago from date
  const getDaysAgo = (dateStr) => {
    try {
      const date = new Date(dateStr);
      const now = new Date();
      const diffTime = Math.abs(now - date);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return '1 day ago';
      return `${diffDays} days ago`;
    } catch (e) {
      return 'Unknown date';
    }
  };

  // Format date for display
  const formatDate = (dateStr) => {
    try {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
      });
    } catch (e) {
      return dateStr || 'Unknown date';
    }
  };

  // Format time for last updated display
  const formatTimeAgo = (date) => {
    try {
      const now = new Date();
      const diff = Math.floor((now - date) / 1000); // Seconds
      
      if (diff < 60) return 'just now';
      if (diff < 3600) return `${Math.floor(diff / 60)} min ago`;
      if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
      return formatDate(date);
    } catch (e) {
      return 'Unknown';
    }
  };

  // Search Modal Component
  const SearchModal = () => (
    <Modal
      visible={showSearchModal}
      animationType="slide"
      transparent={true}
      onRequestClose={() => setShowSearchModal(false)}
    >
      <View style={styles.modalContainer}>
        <View style={styles.searchModalContent}>
          <View style={styles.searchModalHeader}>
            <Text style={styles.searchModalTitle}>Search Location</Text>
            <TouchableOpacity onPress={() => setShowSearchModal(false)}>
              <Ionicons name="close" size={24} color={getThemeColor('neutral.gray700', '#616161')} />
            </TouchableOpacity>
          </View>
          
          <View style={styles.searchInputContainer}>
            <Ionicons name="search" size={20} color={getThemeColor('neutral.gray500', '#9E9E9E')} />
            <TextInput
              style={styles.searchInput}
              placeholder="Enter city, address or landmark"
              value={searchQuery}
              onChangeText={(text) => {
                searchQueryRef.current = text;
                setSearchQuery(text);
              }}
              autoFocus={true}
              returnKeyType="search"
              onSubmitEditing={() => {
                if (!isSearching && searchQuery.trim()) {
                  Keyboard.dismiss();
                  searchLocation();
                }
              }}
              keyboardType="default"
              autoCapitalize="none"
              autoCorrect={false}
              multiline={false}
              blurOnSubmit={false}
              enablesReturnKeyAutomatically={true}
              maxLength={100}
            />
            {searchQuery.length > 0 && (
              <TouchableOpacity onPress={() => {
                setSearchQuery('');
                searchQueryRef.current = '';
              }}>
                <Ionicons name="close-circle" size={20} color={getThemeColor('neutral.gray500', '#9E9E9E')} />
              </TouchableOpacity>
            )}
          </View>
          
          <TouchableOpacity 
            style={[
              styles.searchButton, 
              (!(searchQueryRef.current || searchQuery).trim() || isSearching) && styles.disabledSearchButton
            ]}
            onPress={() => {
              if (!isSearching && (searchQueryRef.current || searchQuery).trim()) {
                Keyboard.dismiss();
                searchLocation();
              }
            }}
            disabled={!(searchQueryRef.current || searchQuery).trim() || isSearching}
          >
            {isSearching ? (
              <ActivityIndicator color="white" size="small" />
            ) : (
              <>
                <Ionicons name="search" size={18} color="white" />
                <Text style={styles.searchButtonText}>Search Location</Text>
              </>
            )}
          </TouchableOpacity>
          
          {/* Recent searches section */}
          {recentSearches.length > 0 && (
            <View style={styles.recentSearchesContainer}>
              <Text style={styles.recentSearchesTitle}>Recent Searches</Text>
              
              {recentSearches.map((search, index) => (
                <TouchableOpacity 
                  key={`${search.query}-${index}`}
                  style={styles.recentSearchItem}
                  onPress={() => {
                    setSearchQuery(search.query);
                    searchQueryRef.current = search.query;
                    Keyboard.dismiss();
                    setTimeout(() => searchLocation(), 100); // Small delay to ensure query is set
                  }}
                >
                  <Ionicons name="time-outline" size={16} color={getThemeColor('neutral.gray500', '#9E9E9E')} />
                  <Text style={styles.recentSearchText}>{search.query}</Text>
                  <Ionicons name="chevron-forward" size={16} color={getThemeColor('neutral.gray400', '#BDBDBD')} />
                </TouchableOpacity>
              ))}
              
              <TouchableOpacity 
                style={styles.clearSearchesButton}
                onPress={() => setRecentSearches([])}
              >
                <Text style={styles.clearSearchesText}>Clear All</Text>
              </TouchableOpacity>
            </View>
          )}
        </View>
      </View>
    </Modal>
  );

  // Filters Modal Component
  const FiltersModal = () => (
    <Modal
      visible={showFilters}
      animationType="slide"
      transparent={true}
      onRequestClose={() => setShowFilters(false)}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Filter Complaints</Text>
            <TouchableOpacity 
              onPress={() => setShowFilters(false)}
              style={styles.closeButton}
            >
              <Ionicons name="close" size={24} color={getThemeColor('neutral.gray700', '#616161')} />
            </TouchableOpacity>
          </View>

          <View style={styles.filterOptions}>
            {[
              { key: 'all', label: 'All Complaints', icon: 'apps' },
              { key: 'pending', label: 'Pending', icon: 'time', color: '#FF4444' },
              { key: 'in_progress', label: 'In Progress', icon: 'sync', color: '#FF8800' },
              { key: 'completed', label: 'Completed', icon: 'checkmark-circle', color: '#00AA44' },
            ].map((option) => (
              <TouchableOpacity
                key={option.key}
                style={[
                  styles.filterOption,
                  filterStatus === option.key && styles.filterOptionActive
                ]}
                onPress={() => {
                  setFilterStatus(option.key);
                  setShowFilters(false);
                }}
              >
                <Ionicons 
                  name={option.icon} 
                  size={24} 
                  color={option.color || getThemeColor('primary.main', '#2E7D32')} 
                />
                <Text style={styles.filterLabel}>{option.label}</Text>
                {filterStatus === option.key && (
                  <Ionicons 
                    name="checkmark-circle" 
                    size={18} 
                    color={getThemeColor('primary.main', '#2E7D32')} 
                    style={styles.checkIcon}
                  />
                )}
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </View>
    </Modal>
  );

  // Complaint Details Modal Component
  const ComplaintDetailsModal = () => {
    if (!selectedComplaint) return null;

    const getStatusIcon = (status) => {
      switch (status) {
        case 'pending': return 'alert-circle';
        case 'in_progress': return 'sync';
        case 'resolved': return 'checkmark-circle';
        default: return 'alert-circle';
      }
    };

    const getStatusColor = (status) => {
      switch (status) {
        case 'pending': return '#FF4444';
        case 'in_progress': return '#FF8800';
        case 'resolved': return '#00AA44';
        default: return '#FF4444';
      }
    };

    const getStatusText = (status) => {
      switch (status) {
        case 'pending': return 'Pending';
        case 'in_progress': return 'In Progress';
        case 'resolved': return 'Resolved';
        default: return 'Unknown';
      }
    };

    const formatDate = (dateString) => {
      const date = new Date(dateString);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    };

    const statusColor = getStatusColor(selectedComplaint.status);
    const statusText = getStatusText(selectedComplaint.status);

    return (
      <Modal
        visible={showComplaintModal}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowComplaintModal(false)}
      >
        <View style={styles.modalContainer}>
          <View style={[styles.modalContent, styles.complaintModalContent]}>
            {/* Header */}
            <View style={[styles.modalHeader, styles.complaintModalHeader]}>
              <View style={styles.complaintHeaderLeft}>
                <View style={[styles.statusBadge, { backgroundColor: statusColor }]}>
                  <Ionicons name={getStatusIcon(selectedComplaint.status)} size={16} color="white" />
                  <Text style={styles.statusBadgeText}>{statusText}</Text>
                </View>
                <Text style={styles.complaintModalTitle} numberOfLines={2}>
                  {selectedComplaint.title}
                </Text>
              </View>
              <TouchableOpacity 
                onPress={() => setShowComplaintModal(false)}
                style={styles.closeButton}
              >
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            {/* Content Scroll View */}
            <ScrollView style={styles.complaintModalScroll} showsVerticalScrollIndicator={false}>
              {/* Description */}
              <View style={styles.complaintSection}>
                <Text style={styles.complaintSectionTitle}>Description</Text>
                <Text style={styles.complaintDescription}>
                  {selectedComplaint.description}
                </Text>
              </View>

              {/* Details Grid */}
              <View style={styles.complaintSection}>
                <Text style={styles.complaintSectionTitle}>Details</Text>
                <View style={styles.detailsGrid}>
                  <View style={styles.detailItem}>
                    <Ionicons name="folder-outline" size={20} color="#666" />
                    <View style={styles.detailContent}>
                      <Text style={styles.detailLabel}>Category</Text>
                      <Text style={styles.detailValue}>{selectedComplaint.category || 'General'}</Text>
                    </View>
                  </View>
                  
                  <View style={styles.detailItem}>
                    <Ionicons name="calendar-outline" size={20} color="#666" />
                    <View style={styles.detailContent}>
                      <Text style={styles.detailLabel}>Reported</Text>
                      <Text style={styles.detailValue}>{formatDate(selectedComplaint.created_at)}</Text>
                    </View>
                  </View>

                  <View style={styles.detailItem}>
                    <Ionicons name="location-outline" size={20} color="#666" />
                    <View style={styles.detailContent}>
                      <Text style={styles.detailLabel}>Location</Text>
                      <Text style={styles.detailValue}>
                        {selectedComplaint.location_address || 
                         `${selectedComplaint.location_latitude}, ${selectedComplaint.location_longitude}`}
                      </Text>
                    </View>
                  </View>

                  <View style={styles.detailItem}>
                    <Ionicons name="star-outline" size={20} color="#666" />
                    <View style={styles.detailContent}>
                      <Text style={styles.detailLabel}>Priority Score</Text>
                      <Text style={styles.detailValue}>
                        {selectedComplaint.priority_score ? 
                         (selectedComplaint.priority_score * 100).toFixed(0) + '%' : 'N/A'}
                      </Text>
                    </View>
                  </View>

                  {selectedComplaint.vote_count && (
                    <View style={styles.detailItem}>
                      <Ionicons name="thumbs-up-outline" size={20} color="#666" />
                      <View style={styles.detailContent}>
                        <Text style={styles.detailLabel}>Community Votes</Text>
                        <Text style={styles.detailValue}>{selectedComplaint.vote_count} votes</Text>
                      </View>
                    </View>
                  )}
                </View>
              </View>

              {/* Images */}
              {selectedComplaint.image_urls && selectedComplaint.image_urls.length > 0 && (
                <View style={styles.complaintSection}>
                  <Text style={styles.complaintSectionTitle}>Photos</Text>
                  <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.imagesContainer}>
                    {selectedComplaint.image_urls.map((imageUrl, index) => (
                      <TouchableOpacity key={index} style={styles.imageItem}>
                        <Image 
                          source={{ uri: imageUrl }} 
                          style={styles.complaintImage}
                          resizeMode="cover"
                        />
                      </TouchableOpacity>
                    ))}
                  </ScrollView>
                </View>
              )}

              {/* Action Buttons */}
              <View style={styles.complaintActions}>
                <TouchableOpacity 
                  style={[styles.actionButton, styles.voteButton]}
                  onPress={() => {
                    // TODO: Implement voting functionality
                    Alert.alert('Vote', 'Voting functionality will be implemented here');
                  }}
                >
                  <Ionicons name="thumbs-up" size={20} color="white" />
                  <Text style={styles.actionButtonText}>Support This Issue</Text>
                </TouchableOpacity>

                <TouchableOpacity 
                  style={[styles.actionButton, styles.shareButton]}
                  onPress={() => {
                    // TODO: Implement share functionality
                    Alert.alert('Share', 'Share functionality will be implemented here');
                  }}
                >
                  <Ionicons name="share-outline" size={20} color="#666" />
                  <Text style={[styles.actionButtonText, { color: '#666' }]}>Share</Text>
                </TouchableOpacity>
              </View>
            </ScrollView>
          </View>
        </View>
      </Modal>
    );
  };

  // Calculate distance between two coordinates in kilometers
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371; // Radius of the earth in km
    const dLat = deg2rad(lat2 - lat1);
    const dLon = deg2rad(lon2 - lon1);
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
      Math.sin(dLon/2) * Math.sin(dLon/2); 
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    const distance = R * c; // Distance in km
    return distance;
  };
  
  // Helper function for distance calculation
  const deg2rad = (deg) => {
    return deg * (Math.PI/180);
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor={getThemeColor('primary.main', '#2E7D32')} />
      
      {/* Header */}
      <LinearGradient
        colors={EnvironmentalTheme?.gradients?.forest || ['#1B5E20', '#2E7D32', '#60AD5E']}
        style={styles.header}
      >
        <View style={styles.headerContent}>
          <TouchableOpacity 
            onPress={() => navigation.goBack()}
            style={styles.backButton}
          >
            <Ionicons name="arrow-back" size={24} color="white" />
          </TouchableOpacity>
          
          <View style={styles.headerTitleContainer}>
            <Ionicons name="map" size={24} color="white" />
            <Text style={styles.headerTitle}>Complaint Map</Text>
          </View>

          <TouchableOpacity 
            onPress={() => setShowFilters(true)}
            style={styles.filterButton}
          >
            <Ionicons name="filter" size={24} color="white" />
          </TouchableOpacity>
        </View>
        
        {/* Search Bar */}
        <TouchableOpacity 
          style={styles.searchBar}
          onPress={() => {
            // Don't clear the previous search when opening modal
            setShowSearchModal(true);
          }}
        >
          <Ionicons name="search" size={20} color={getThemeColor('neutral.gray500', '#9E9E9E')} />
          <Text style={styles.searchPlaceholder}>Tap to search for city, landmark or address...</Text>
          <Ionicons name="locate" size={20} color={getThemeColor('primary.main', '#2E7D32')} />
        </TouchableOpacity>

        {/* Statistics Bar */}
        {statistics && (
          <View style={styles.statsBar}>
            <View style={styles.statItem}>
              <View style={[styles.statIndicator, { backgroundColor: getStatusColor('pending') }]} />
              <Text style={styles.statText}>{statistics.pending} Registered</Text>
            </View>
            <View style={styles.statItem}>
              <View style={[styles.statIndicator, { backgroundColor: getStatusColor('in_progress') }]} />
              <Text style={styles.statText}>{statistics.active} In Progress</Text>
            </View>
            <View style={styles.statItem}>
              <View style={[styles.statIndicator, { backgroundColor: getStatusColor('completed') }]} />
              <Text style={styles.statText}>{statistics.resolved} Solved</Text>
            </View>
          </View>
        )}
      </LinearGradient>
      
      {/* Search Modal */}
      <SearchModal />
      
      {/* Filters Modal */}
      <FiltersModal />

      {/* Complaint Details Modal */}
      <ComplaintDetailsModal />

      {/* Map Container */}
      <View style={styles.mapContainer}>
        {loading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={getThemeColor('primary.main', '#2E7D32')} />
            <Text style={styles.loadingText}>Loading map...</Text>
          </View>
        )}
        
        <MapView
          ref={(ref) => setMapRef(ref)}
          style={styles.map}
          initialRegion={region}
          region={region}
          onRegionChangeComplete={setRegion}
          showsUserLocation={true}
          showsMyLocationButton={false}
          showsCompass={true}
          loadingEnabled={true}
          zoomEnabled={true}
          zoomControlEnabled={true}
          provider="google"
          mapType="standard"
        >
          {/* SIMPLE COMPLAINT MARKERS - CLEAN START */}
          
          {/* Render complaint markers with enhanced design */}
          {console.log(`üó∫Ô∏è About to render ${getFilteredComplaints().length} complaint markers`)}
          {getFilteredComplaints().length > 0 && 
            getFilteredComplaints().map((complaint, index) => {
              // Use the correct field names from API response
              const lat = parseFloat(complaint.location_latitude || 0);
              const lng = parseFloat(complaint.location_longitude || 0);
              
              // Skip invalid coordinates
              if (lat === 0 || lng === 0 || isNaN(lat) || isNaN(lng)) {
                console.log(`‚ùå Skipping complaint ${complaint.id} (${complaint.title}) with invalid coordinates: ${lat}, ${lng}`);
                return null;
              }
              
              console.log(`‚úÖ Rendering marker ${index + 1}/${getFilteredComplaints().length}: ${complaint.title} at ${lat}, ${lng} - Status: ${complaint.status}`);
              
              const statusColor = getStatusColor(complaint.status);
              const statusText = getStatusText(complaint.status);
              const daysAgo = getDaysAgo(complaint.created_at);
              
              console.log(`üéØ Rendering custom pin for complaint: ${complaint.title} at (${lat}, ${lng}) with status: ${complaint.status} -> color: ${statusColor}`);
              console.log(`üìç Pin component will render mapPinContainer with mapPinHead (${statusColor}) and mapPinTail`);
              
              return (
                <Marker
                  key={complaint.id}
                  coordinate={{
                    latitude: lat,
                    longitude: lng
                  }}
                  title={complaint.title}
                  description={`Status: ${statusText} | ${complaint.description.substring(0, 50)}...`}
                  pinColor={statusColor}
                  onPress={() => {
                    console.log('üéØ Pin pressed for complaint:', complaint.title);
                    setSelectedComplaint(complaint);
                    setShowComplaintModal(true);
                  }}
                  onCalloutPress={() => {
                    console.log('üéØ Callout pressed for complaint:', complaint.title);
                    setSelectedComplaint(complaint);
                    setShowComplaintModal(true);
                  }}
                />
                  <Callout tooltip style={styles.calloutTooltip}>
                    <View style={[styles.enhancedCalloutContainer, { borderLeftColor: statusColor }]}>
                      {/* Header with status indicator */}
                      <View style={styles.calloutHeader}>
                        <View style={[styles.statusIndicator, { backgroundColor: statusColor }]} />
                        <Text style={styles.enhancedCalloutTitle} numberOfLines={2}>{complaint.title}</Text>
                      </View>
                      
                      {/* Description */}
                      <Text style={styles.enhancedCalloutDescription} numberOfLines={3}>
                        {complaint.description}
                      </Text>
                      
                      {/* Details section */}
                      <View style={styles.calloutDetailsSection}>
                        {/* Status */}
                        <View style={styles.detailRow}>
                          <Ionicons name="flag" size={14} color={statusColor} />
                          <Text style={styles.detailLabel}>Status:</Text>
                          <Text style={[styles.detailValue, { color: statusColor, fontWeight: 'bold' }]}>
                            {statusText}
                          </Text>
                        </View>
                        
                        {/* Category */}
                        <View style={styles.detailRow}>
                          <Ionicons name="folder" size={14} color="#666" />
                          <Text style={styles.detailLabel}>Category:</Text>
                          <Text style={styles.detailValue}>{complaint.category || 'General'}</Text>
                        </View>
                        
                        {/* Date raised */}
                        <View style={styles.detailRow}>
                          <Ionicons name="calendar" size={14} color="#666" />
                          <Text style={styles.detailLabel}>Raised:</Text>
                          <Text style={styles.detailValue}>{daysAgo}</Text>
                        </View>
                        
                        {/* Priority Score */}
                        {complaint.priority_score && (
                          <View style={styles.detailRow}>
                            <Ionicons name="alert-circle" size={14} color="#FF8800" />
                            <Text style={styles.detailLabel}>Priority:</Text>
                            <Text style={styles.detailValue}>
                              {Math.round(complaint.priority_score * 100)}%
                            </Text>
                          </View>
                        )}
                        
                        {/* Location address if available */}
                        {complaint.location_address && (
                          <View style={styles.detailRow}>
                            <Ionicons name="location" size={14} color="#666" />
                            <Text style={styles.detailLabel}>Location:</Text>
                            <Text style={styles.detailValue} numberOfLines={1}>
                              {complaint.location_address}
                            </Text>
                          </View>
                        )}
                        
                        {/* Resolution date for completed complaints */}
                        {complaint.status === 'completed' && complaint.resolved_at && (
                          <View style={styles.detailRow}>
                            <Ionicons name="checkmark-circle" size={14} color="#00AA44" />
                            <Text style={styles.detailLabel}>Resolved:</Text>
                            <Text style={styles.detailValue}>
                              {getDaysAgo(complaint.resolved_at)}
                            </Text>
                          </View>
                        )}
                      </View>
                      
                      {/* Footer */}
                      <View style={styles.calloutFooter}>
                        <Text style={styles.calloutId}>ID: {complaint.id.slice(-8)}</Text>
                        <TouchableOpacity 
                          style={styles.viewDetailsButton}
                          onPress={() => {
                            // Close callout and show detailed modal
                            setSelectedComplaint(complaint);
                            setShowComplaintModal(true);
                          }}
                        >
                          <Text style={styles.viewDetailsText}>View Details</Text>
                          <Ionicons name="chevron-forward" size={12} color="#0066CC" />
                        </TouchableOpacity>
                      </View>
                    </View>
                  </Callout>
                </Marker>
              );
            })
          }
          
          {/* Render search result marker if available */}
          {searchMarker && (
            <Marker
              key="search-marker"
              coordinate={{
                latitude: searchMarker.latitude,
                longitude: searchMarker.longitude
              }}
              anchor={{ x: 0.5, y: 1 }}
              centerOffset={{ x: 0, y: -18 }}
            >
              <View style={{
                width: 40,
                height: 40,
                backgroundColor: '#3498db',
                borderRadius: 20,
                borderWidth: 3,
                borderColor: 'white',
                alignItems: 'center',
                justifyContent: 'center',
                shadowColor: '#000',
                shadowOffset: { width: 0, height: 3 },
                shadowOpacity: 0.5,
                shadowRadius: 4,
                elevation: 8,
              }}>
                <Ionicons name="search" size={20} color="white" />
              </View>
              <Callout tooltip>
                <View style={[styles.calloutContainer, styles.searchCalloutContainer]}>
                  <Text style={styles.calloutTitle}>
                    <Ionicons name="location" size={14} color="#3498db" /> Searched Location
                  </Text>
                  <Text style={styles.calloutDescription}>
                    {searchMarker.title || searchMarker.description || 'Location found from your search'}
                  </Text>
                  <TouchableOpacity 
                    style={styles.searchDirectionsButton}
                    onPress={() => {
                      // Clear search marker
                      setSearchMarker(null);
                      
                      // Alert for demo purposes - in real app would open maps
                      Alert.alert(
                        'Get Directions',
                        'This would open maps app with directions in a real app.',
                        [{ text: 'OK' }]
                      );
                    }}
                  >
                    <Text style={styles.searchDirectionsText}>Get Directions</Text>
                  </TouchableOpacity>
                </View>
              </Callout>
            </Marker>
          )}
        </MapView>
      </View>

      {/* Loading Indicator */}
      {loading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={getThemeColor('primary.main', '#2E7D32')} />
          <Text style={styles.loadingText}>Loading complaints...</Text>
        </View>
      )}
      
      {/* No Data Message */}
      {!loading && getFilteredComplaints().length === 0 && (
        <View style={styles.emptyStateContainer}>
          <Ionicons 
            name="alert-circle-outline" 
            size={64} 
            color={EnvironmentalTheme.neutral.gray500 || '#9E9E9E'} 
          />
          <Text style={styles.emptyStateTitle}>No Complaints Found</Text>
          <Text style={styles.emptyStateText}>There are no complaints to display for the current filter settings.</Text>
          <TouchableOpacity 
            style={[
              styles.emptyStateButton, 
              isFetching && styles.disabledButton
            ]}
            onPress={() => !isFetchingRef.current && fetchComplaintData()}
            disabled={isFetching || isFetchingRef.current}
          >
            <Text style={styles.emptyStateButtonText}>
              {isFetching || isFetchingRef.current ? 'Loading...' : 'Refresh Data'}
            </Text>
          </TouchableOpacity>
        </View>
      )}

      {/* Refresh Button */}
      <TouchableOpacity
        style={[
          styles.refreshButton,
          (isFetching || isFetchingRef.current) && styles.disabledButton
        ]}
        onPress={() => !isFetchingRef.current && fetchComplaintData()}
        disabled={isFetching || isFetchingRef.current}
      >
        <LinearGradient
          colors={
            (isFetching || isFetchingRef.current)
              ? ['#A5D6A7', '#C8E6C9']  // Lighter colors when disabled
              : [getThemeColor('primary.main', '#2E7D32'), getThemeColor('primary.light', '#60AD5E')]
          }
          style={styles.refreshGradient}
        >
          {(isFetching || isFetchingRef.current) ? (
            <ActivityIndicator size="small" color="white" />
          ) : (
            <Ionicons name="refresh" size={20} color="white" />
          )}
        </LinearGradient>
      </TouchableOpacity>
      
      {/* Auto-Refresh Toggle */}
      <TouchableOpacity
        style={[
          styles.autoRefreshButton,
          autoRefresh && styles.autoRefreshButtonActive
        ]}
        onPress={() => setAutoRefresh(!autoRefresh)}
      >
        <LinearGradient
          colors={
            autoRefresh 
              ? [getThemeColor('status.success', '#4CAF50'), getThemeColor('status.success', '#388E3C')]
              : [getThemeColor('neutral.gray400', '#BDBDBD'), getThemeColor('neutral.gray600', '#757575')]
          }
          style={styles.refreshGradient}
        >
          <View style={styles.autoRefreshContent}>
            <Ionicons 
              name={autoRefresh ? "sync-circle" : "sync"} 
              size={18} 
              color="white" 
            />
            <Text style={styles.autoRefreshText}>
              {autoRefresh ? 'Auto' : 'Live'}
            </Text>
          </View>
        </LinearGradient>
      </TouchableOpacity>
      
      {/* Heatmap Toggle with enhanced feedback */}
      <TouchableOpacity
        style={[
          styles.heatmapButton,
          showHeatmap && styles.heatmapButtonActive
        ]}
        onPress={() => {
          setShowHeatmap(!showHeatmap);
          // Show feedback to user
          if (!showHeatmap && heatMapData && Array.isArray(heatMapData) && heatMapData.length > 0) {
            Alert.alert(
              "Heatmap Activated", 
              `Showing ${heatMapData.length} priority hotspots on the map.`,
              [{ text: "OK", style: "default" }],
              { cancelable: true }
            );
          }
        }}
      >
        <LinearGradient
          colors={
            showHeatmap 
              ? [getThemeColor('status.warning', '#FFA000'), getThemeColor('status.danger', '#FF5722')]
              : [getThemeColor('neutral.gray400', '#BDBDBD'), getThemeColor('neutral.gray600', '#757575')]
          }
          style={styles.refreshGradient}
        >
          <View style={styles.heatmapContent}>
            <MaterialIcons 
              name={showHeatmap ? "layers" : "layers-clear"} 
              size={18} 
              color="white" 
            />
            <Text style={styles.heatmapText}>
              {showHeatmap ? 'Heatmap On' : 'Heatmap Off'}
            </Text>
          </View>
        </LinearGradient>
      </TouchableOpacity>
      
      {/* My Location Button */}
      <TouchableOpacity
        style={styles.myLocationButton}
        onPress={goToUserLocation}
      >
        <LinearGradient
          colors={[getThemeColor('secondary.light', '#58A5F0'), getThemeColor('secondary.main', '#0277BD')]}
          style={styles.myLocationGradient}
        >
          <Ionicons name="locate" size={24} color="white" />
        </LinearGradient>
      </TouchableOpacity>
      
      {/* Show All Complaints Button */}
      <TouchableOpacity
        style={[styles.myLocationButton, styles.showAllButton]}
        onPress={() => {
          if (complaints && complaints.length > 0) {
            fitMapToComplaints(complaints);
          }
        }}
      >
        <LinearGradient
          colors={[getThemeColor('primary.light', '#60AD5E'), getThemeColor('primary.main', '#2E7D32')]}
          style={styles.myLocationGradient}
        >
          <Ionicons name="apps" size={24} color="white" />
        </LinearGradient>
      </TouchableOpacity>
      
      {/* Test API Button - for debugging */}
      <TouchableOpacity
        style={[styles.myLocationButton, styles.testButton]}
        onPress={testApiEndpoints}
      >
        <LinearGradient
          colors={[getThemeColor('warning.light', '#FFA726'), getThemeColor('warning.main', '#F57C00')]}
          style={styles.myLocationGradient}
        >
          <Ionicons name="code-working" size={24} color="white" />
        </LinearGradient>
      </TouchableOpacity>
      
      {/* Jump to specific complaint - for debugging */}
      <TouchableOpacity
        style={[styles.myLocationButton, styles.jumpToComplaintButton]}
        onPress={() => {
          // Jump to your specific complaint at coordinates 10.9837, 76.9266
          const yourComplaintRegion = {
            latitude: 10.9837,
            longitude: 76.9266,
            latitudeDelta: 0.01, // Close zoom
            longitudeDelta: 0.01,
          };
          console.log('üéØ Jumping to your complaint at 10.9837, 76.9266');
          setRegion(yourComplaintRegion);
          if (mapRef) {
            mapRef.animateToRegion(yourComplaintRegion, 1000);
          }
        }}
      >
        <LinearGradient
          colors={[getThemeColor('accent.amber', '#FFA726'), getThemeColor('accent.orange', '#FF7043')]}
          style={styles.myLocationGradient}
        >
          <Ionicons name="flag" size={24} color="white" />
        </LinearGradient>
      </TouchableOpacity>

      {/* Generate Heatmap Button - for debugging */}
      <TouchableOpacity
        style={[styles.myLocationButton, styles.testHeatmapButton]}
        onPress={generateHeatmapFromComplaints}
      >
        <LinearGradient
          colors={[getThemeColor('error.light', '#F48FB1'), getThemeColor('error.main', '#E91E63')]}
          style={styles.myLocationGradient}
        >
          <MaterialIcons name="grain" size={24} color="white" />
        </LinearGradient>
      </TouchableOpacity>

      {/* Last Updated */}
      <View style={styles.lastUpdatedContainer}>
        <Ionicons name="time-outline" size={14} color={getThemeColor('neutral.gray600', '#757575')} />
        <Text style={styles.lastUpdatedText}>Updated {formatTimeAgo(lastUpdated)}</Text>
      </View>
      
      {/* Debug info for complaints and heatmap */}
      <View style={styles.debugComplaintsOverlay}>
        <Text style={styles.debugText}>
          üìç Complaints: {getFilteredComplaints().length} pins | Filter: {filterStatus}
        </Text>
        {statistics && (
          <Text style={styles.debugText}>
            üî¥ {statistics.pending} Registered ‚Ä¢ üü° {statistics.active} Progress ‚Ä¢ üü¢ {statistics.resolved} Solved
          </Text>
        )}
      </View>
      
      {/* Debug info for heatmap */}
      {showHeatmap && (
        <View style={styles.debugHeatmapOverlay}>
          <Text style={styles.debugText}>
            {heatMapData && Array.isArray(heatMapData) && heatMapData.length > 0 
              ? `Hotspots: ${heatMapData.length} visible | 
                 Tap hotspots to view details` 
              : "No hotspot data available (try test button)"}
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  mapContainer: {
    flex: 1,
    position: 'relative',
  },
  loadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(255,255,255,0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#2E7D32',
  },
  disabledButton: {
    opacity: 0.7,
  },
  disabledSearchButton: {
    opacity: 0.6,
    backgroundColor: '#A5D6A7', // Lighter green
  },
  recentSearchesContainer: {
    marginTop: 8,
  },
  recentSearchesTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    color: '#424242',
  },
  recentSearchItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  recentSearchText: {
    flex: 1,
    marginLeft: 12,
    color: '#616161',
    fontSize: 14,
  },
  clearSearchesButton: {
    alignSelf: 'flex-end',
    marginTop: 12,
    padding: 8,
  },
  clearSearchesText: {
    color: '#F44336',
    fontSize: 14,
  },
  header: {
    paddingTop: StatusBar.currentHeight || 50,
    paddingBottom: 12,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  headerTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  headerTitle: {
    color: 'white',
    fontSize: 20,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  backButton: {
    padding: 4,
  },
  filterButton: {
    padding: 4,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 24,
    marginHorizontal: 16,
    marginVertical: 8,
    paddingHorizontal: 16,
    paddingVertical: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
  },
  searchPlaceholder: {
    flex: 1,
    marginLeft: 8,
    color: '#9E9E9E',
    fontSize: 14,
  },
  map: {
    flex: 1,
  },
  statsBar: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    marginHorizontal: 16,
    marginTop: 4,
    paddingVertical: 8,
    borderRadius: 16,
  },
  statItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statIndicator: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 4,
  },
  statText: {
    fontSize: 12,
    color: '#616161',
  },
  calloutContainer: {
    width: 200,
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 12,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 3,
  },
  calloutTitle: {
    fontWeight: 'bold',
    fontSize: 14,
    marginBottom: 4,
    color: '#333333',
  },
  calloutDescription: {
    fontSize: 12,
    marginBottom: 8,
    color: '#666666',
  },
  calloutDetails: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  calloutStatus: {
    paddingVertical: 2,
    paddingHorizontal: 6,
    borderRadius: 4,
  },
  calloutStatusText: {
    fontSize: 10,
    color: 'white',
    fontWeight: 'bold',
  },
  calloutDate: {
    fontSize: 10,
    color: '#9E9E9E',
  },
  // Enhanced callout styles
  calloutTooltip: {
    flex: 1,
  },
  enhancedCalloutContainer: {
    width: 300,
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 16,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    borderLeftWidth: 4,
    maxHeight: 400,
  },
  calloutHeader: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  statusIndicator: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginRight: 8,
    marginTop: 2,
  },
  enhancedCalloutTitle: {
    flex: 1,
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    lineHeight: 20,
  },
  enhancedCalloutDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16,
    lineHeight: 18,
  },
  calloutDetailsSection: {
    marginBottom: 12,
  },
  detailRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    paddingVertical: 2,
  },
  detailLabel: {
    fontSize: 12,
    color: '#888',
    marginLeft: 6,
    marginRight: 8,
    minWidth: 60,
  },
  detailValue: {
    flex: 1,
    fontSize: 12,
    color: '#333',
    fontWeight: '500',
  },
  calloutFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  calloutId: {
    fontSize: 10,
    color: '#aaa',
    fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace',
  },
  viewDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    backgroundColor: '#f8f9fa',
  },
  viewDetailsText: {
    fontSize: 12,
    color: '#0066CC',
    fontWeight: '600',
    marginRight: 4,
  },
  // Map Pin Styles - Large Visible Pin Shape
  mapPinContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    width: 50,
    height: 60,
  },
  mapPinHead: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 4,
    borderColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.6,
    shadowRadius: 6,
    elevation: 10,
  },
  mapPinTail: {
    width: 0,
    height: 0,
    borderLeftWidth: 10,
    borderRightWidth: 10,
    borderTopWidth: 15,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    marginTop: -2,
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.7)',
  },
  refreshButton: {
    position: 'absolute',
    bottom: 90, // Above the bottom navigation if any
    right: 16,
    width: 54,
    height: 54,
    borderRadius: 27,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
  },
  refreshGradient: {
    width: 54,
    height: 54,
    borderRadius: 27,
    justifyContent: 'center',
    alignItems: 'center',
  },
  autoRefreshButton: {
    position: 'absolute',
    bottom: 154, // Above the refresh button
    right: 16,
    width: 80,
    height: 34,
    borderRadius: 17,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
  },
  heatmapButton: {
    position: 'absolute',
    bottom: 198, // Above the auto-refresh button
    right: 16,
    width: 120,
    height: 34,
    borderRadius: 17,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
  },
  myLocationButton: {
    position: 'absolute',
    bottom: 20,
    right: 16,
    width: 54,
    height: 54,
    borderRadius: 27,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
  },
  myLocationGradient: {
    width: 54,
    height: 54,
    borderRadius: 27,
    justifyContent: 'center',
    alignItems: 'center',
  },
  testButton: {
    bottom: 170, // Position above the location button
    right: 16,
  },
  jumpToComplaintButton: {
    bottom: 230, // Position above the test API button
    right: 16,
  },
  testHeatmapButton: {
    bottom: 290, // Position above the jump button
    right: 16,
  },
  showAllButton: {
    bottom: 84, // Position above the my location button
    right: 16,
  },
  debugComplaintsOverlay: {
    position: 'absolute',
    top: 120,
    left: 10,
    right: 10,
    zIndex: 1000,
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(46, 125, 50, 0.9)', // Environmental green
  },
  debugHeatmapOverlay: {
    position: 'absolute',
    top: 180,
    left: 10,
    zIndex: 1000,
    padding: 8,
    borderRadius: 8,
    backgroundColor: 'rgba(0,0,0,0.7)',
  },
  debugText: {
    color: 'white',
    padding: 2,
    fontSize: 11,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  heatpointMarker: {
    width: 20,
    height: 20,
    borderRadius: 10,
    backgroundColor: 'rgba(255,100,0,0.7)',
  },
  autoRefreshButtonActive: {
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
  },
  heatmapButtonActive: {
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
  },
  autoRefreshContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  heatmapContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  autoRefreshText: {
    color: 'white',
    fontWeight: 'bold',
    marginLeft: 4,
    fontSize: 12,
  },
  heatmapText: {
    color: 'white',
    fontWeight: 'bold',
    marginLeft: 4,
    fontSize: 12,
  },
  lastUpdatedContainer: {
    position: 'absolute',
    bottom: 30,
    right: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 12,
  },
  lastUpdatedText: {
    color: '#757575',
    marginLeft: 4,
    fontSize: 11,
  },
  emptyStateContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    padding: 32,
  },
  emptyStateTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: EnvironmentalTheme.primary.main || '#2E7D32',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyStateText: {
    fontSize: 16,
    color: EnvironmentalTheme.neutral.gray700 || '#616161',
    textAlign: 'center',
    marginBottom: 24,
  },
  emptyStateButton: {
    backgroundColor: EnvironmentalTheme.primary.main || '#2E7D32',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 24,
  },
  emptyStateButtonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
  },
  searchCalloutContainer: {
    backgroundColor: '#FFFFFF',
    borderLeftColor: '#3498db',
    borderLeftWidth: 4,
  },
  searchDirectionsButton: {
    backgroundColor: '#3498db',
    padding: 8,
    borderRadius: 4,
    marginTop: 8,
    alignItems: 'center',
  },
  searchDirectionsText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 12,
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  searchModalContent: {
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    maxHeight: '80%',
  },
  searchModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  searchModalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  searchInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    borderRadius: 8,
    paddingHorizontal: 12,
    marginBottom: 16,
  },
  searchInput: {
    flex: 1,
    height: 46,
    paddingHorizontal: 8,
    fontSize: 16,
  },
  searchButton: {
    backgroundColor: '#2E7D32',
    borderRadius: 8,
    paddingVertical: 12,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  searchButtonText: {
    color: 'white',
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalContent: {
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  filterOptions: {
    marginTop: 8,
  },
  filterOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginBottom: 8,
  },
  filterOptionActive: {
    backgroundColor: '#E8F5E9',
  },
  filterLabel: {
    marginLeft: 16,
    fontSize: 16,
    color: '#424242',
    flex: 1,
  },
  checkIcon: {
    marginLeft: 8,
  },
  // Complaint Details Modal Styles
  complaintModalContent: {
    maxHeight: '90%',
    paddingBottom: 0,
  },
  complaintModalHeader: {
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    paddingBottom: 16,
    marginBottom: 0,
  },
  complaintHeaderLeft: {
    flex: 1,
    marginRight: 16,
  },
  statusBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    alignSelf: 'flex-start',
    marginBottom: 8,
  },
  statusBadgeText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
    marginLeft: 4,
  },
  complaintModalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    lineHeight: 26,
  },
  complaintModalScroll: {
    flex: 1,
  },
  complaintSection: {
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  complaintSectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  complaintDescription: {
    fontSize: 15,
    lineHeight: 22,
    color: '#555',
  },
  detailsGrid: {
    gap: 16,
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  detailContent: {
    marginLeft: 12,
    flex: 1,
  },
  detailLabel: {
    fontSize: 12,
    color: '#888',
    textTransform: 'uppercase',
    fontWeight: '500',
    marginBottom: 2,
  },
  detailValue: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  imagesContainer: {
    paddingTop: 8,
  },
  imageItem: {
    marginRight: 12,
  },
  complaintImage: {
    width: 120,
    height: 120,
    borderRadius: 8,
    backgroundColor: '#f5f5f5',
  },
  complaintActions: {
    padding: 20,
    gap: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    gap: 8,
  },
  voteButton: {
    backgroundColor: '#4CAF50',
  },
  shareButton: {
    backgroundColor: '#f5f5f5',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  actionButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: 'white',
  },
});

export default ComplaintMapScreen;
